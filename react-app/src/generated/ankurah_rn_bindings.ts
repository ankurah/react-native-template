// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceCounterCallback,
  type UniffiVTableCallbackInterfaceLogCallback,
} from './ankurah_rn_bindings-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Get the default storage path for the current platform
 * On iOS/macOS, this uses the user's home directory
 * On other platforms, falls back to a relative path
 */
export function getDefaultStoragePath(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ callStatus => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_get_default_storage_path(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the node's ID as a string
 */
export function getNodeId(): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeAnkurahError.lift.bind(
        FfiConverterTypeAnkurahError,
      ),
      /*caller:*/ callStatus => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_get_node_id(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Simple sync function to verify FFI works
 */
export function greet(name: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ callStatus => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_greet(
          FfiConverterString.lower(name),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Async function to verify promises work across FFI
 */
export async function greetAsync(
  name: string,
  delayMs: /*u64*/ bigint,
  asyncOpts_?: { signal: AbortSignal },
): Promise<string> {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_greet_async(
          FfiConverterString.lower(name),
          FfiConverterUInt64.lower(delayMs),
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_ankurah_rn_bindings_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ankurah_rn_bindings_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ankurah_rn_bindings_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_ankurah_rn_bindings_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Initialize the Ankurah node with local Sled storage and connect to server
 *
 * This spawns initialization in a background tokio task and returns immediately.
 * Use `is_node_initialized()` to check when initialization is complete.
 *
 * Args:
 * storage_path: Path to store the Sled database (e.g., app's documents directory)
 * server_url: Optional WebSocket server URL (defaults to ws://localhost:9797)
 */
export function initNode(
  storagePath: string,
  serverUrl: string | undefined,
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeAnkurahError.lift.bind(
      FfiConverterTypeAnkurahError,
    ),
    /*caller:*/ callStatus => {
      nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_init_node(
        FfiConverterString.lower(storagePath),
        FfiConverterOptionalString.lower(serverUrl),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Check if the node is initialized
 */
export function isNodeInitialized(): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ callStatus => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_is_node_initialized(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Set up logging with a callback to receive log messages in JS
 * Should be called once at app startup before init_node
 */
export function setupLogging(callback: LogCallback): void {
  uniffiCaller.rustCall(
    /*caller:*/ callStatus => {
      nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_func_setup_logging(
        FfiConverterTypeLogCallback.lower(callback),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}

/**
 * Callback interface - JS implements this, Rust calls it
 */
export interface CounterCallback {
  onUpdate(count: /*u32*/ number): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceCounterCallback: {
  vtable: UniffiVTableCallbackInterfaceCounterCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, count: number) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeCounterCallback.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterUInt32.lift(count));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower,
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // CounterCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeCounterCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_init_callback_vtable_countercallback(
      uniffiCallbackInterfaceCounterCallback.vtable,
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeCounterCallback =
  new FfiConverterCallback<CounterCallback>();

/**
 * Callback interface for receiving log messages in JS
 */
export interface LogCallback {
  /**
   * Called when a log message is emitted
   * level: "TRACE", "DEBUG", "INFO", "WARN", "ERROR"
   */
  onLog(level: string, target: string, message: string): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogCallback: {
  vtable: UniffiVTableCallbackInterfaceLogCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onLog: (
      uniffiHandle: bigint,
      level: Uint8Array,
      target: Uint8Array,
      message: Uint8Array,
    ) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeLogCallback.lift(uniffiHandle);
        return jsCallback.onLog(
          FfiConverterString.lift(level),
          FfiConverterString.lift(target),
          FfiConverterString.lift(message),
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower,
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // LogCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLogCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_init_callback_vtable_logcallback(
      uniffiCallbackInterfaceLogCallback.vtable,
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogCallback = new FfiConverterCallback<LogCallback>();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall(status =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall(status =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall(status =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: AnkurahError

// Enum: AnkurahError
export enum AnkurahError_Tags {
  Storage = 'Storage',
  Connection = 'Connection',
  NotInitialized = 'NotInitialized',
  AlreadyInitialized = 'AlreadyInitialized',
  Internal = 'Internal',
}
/**
 * Error type for Ankurah operations
 */
export const AnkurahError = (() => {
  type Storage__interface = {
    tag: AnkurahError_Tags.Storage;
    inner: Readonly<{ message: string }>;
  };

  class Storage_ extends UniffiError implements Storage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AnkurahError';
    readonly tag = AnkurahError_Tags.Storage;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('AnkurahError', 'Storage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Storage_ {
      return new Storage_(inner);
    }

    static instanceOf(obj: any): obj is Storage_ {
      return obj.tag === AnkurahError_Tags.Storage;
    }

    static hasInner(obj: any): obj is Storage_ {
      return Storage_.instanceOf(obj);
    }

    static getInner(obj: Storage_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  type Connection__interface = {
    tag: AnkurahError_Tags.Connection;
    inner: Readonly<{ message: string }>;
  };

  class Connection_ extends UniffiError implements Connection__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AnkurahError';
    readonly tag = AnkurahError_Tags.Connection;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('AnkurahError', 'Connection');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Connection_ {
      return new Connection_(inner);
    }

    static instanceOf(obj: any): obj is Connection_ {
      return obj.tag === AnkurahError_Tags.Connection;
    }

    static hasInner(obj: any): obj is Connection_ {
      return Connection_.instanceOf(obj);
    }

    static getInner(obj: Connection_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  type NotInitialized__interface = {
    tag: AnkurahError_Tags.NotInitialized;
  };

  class NotInitialized_
    extends UniffiError
    implements NotInitialized__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AnkurahError';
    readonly tag = AnkurahError_Tags.NotInitialized;
    constructor() {
      super('AnkurahError', 'NotInitialized');
    }

    static new(): NotInitialized_ {
      return new NotInitialized_();
    }

    static instanceOf(obj: any): obj is NotInitialized_ {
      return obj.tag === AnkurahError_Tags.NotInitialized;
    }

    static hasInner(obj: any): obj is NotInitialized_ {
      return false;
    }
  }

  type AlreadyInitialized__interface = {
    tag: AnkurahError_Tags.AlreadyInitialized;
  };

  class AlreadyInitialized_
    extends UniffiError
    implements AlreadyInitialized__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AnkurahError';
    readonly tag = AnkurahError_Tags.AlreadyInitialized;
    constructor() {
      super('AnkurahError', 'AlreadyInitialized');
    }

    static new(): AlreadyInitialized_ {
      return new AlreadyInitialized_();
    }

    static instanceOf(obj: any): obj is AlreadyInitialized_ {
      return obj.tag === AnkurahError_Tags.AlreadyInitialized;
    }

    static hasInner(obj: any): obj is AlreadyInitialized_ {
      return false;
    }
  }

  type Internal__interface = {
    tag: AnkurahError_Tags.Internal;
    inner: Readonly<{ message: string }>;
  };

  class Internal_ extends UniffiError implements Internal__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AnkurahError';
    readonly tag = AnkurahError_Tags.Internal;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('AnkurahError', 'Internal');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Internal_ {
      return new Internal_(inner);
    }

    static instanceOf(obj: any): obj is Internal_ {
      return obj.tag === AnkurahError_Tags.Internal;
    }

    static hasInner(obj: any): obj is Internal_ {
      return Internal_.instanceOf(obj);
    }

    static getInner(obj: Internal_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is AnkurahError {
    return obj[uniffiTypeNameSymbol] === 'AnkurahError';
  }

  return Object.freeze({
    instanceOf,
    Storage: Storage_,
    Connection: Connection_,
    NotInitialized: NotInitialized_,
    AlreadyInitialized: AlreadyInitialized_,
    Internal: Internal_,
  });
})();

/**
 * Error type for Ankurah operations
 */

export type AnkurahError = InstanceType<
  (typeof AnkurahError)[keyof Omit<typeof AnkurahError, 'instanceOf'>]
>;

// FfiConverter for enum AnkurahError
const FfiConverterTypeAnkurahError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AnkurahError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AnkurahError.Storage({
            message: FfiConverterString.read(from),
          });
        case 2:
          return new AnkurahError.Connection({
            message: FfiConverterString.read(from),
          });
        case 3:
          return new AnkurahError.NotInitialized();
        case 4:
          return new AnkurahError.AlreadyInitialized();
        case 5:
          return new AnkurahError.Internal({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AnkurahError_Tags.Storage: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case AnkurahError_Tags.Connection: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case AnkurahError_Tags.NotInitialized: {
          ordinalConverter.write(3, into);
          return;
        }
        case AnkurahError_Tags.AlreadyInitialized: {
          ordinalConverter.write(4, into);
          return;
        }
        case AnkurahError_Tags.Internal: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that AnkurahError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AnkurahError_Tags.Storage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case AnkurahError_Tags.Connection: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case AnkurahError_Tags.NotInitialized: {
          return ordinalConverter.allocationSize(3);
        }
        case AnkurahError_Tags.AlreadyInitialized: {
          return ordinalConverter.allocationSize(4);
        }
        case AnkurahError_Tags.Internal: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Counter object that calls back to JS on each increment
 */
export interface CounterInterface {
  get(): /*u32*/ number;
  increment(): /*u32*/ number;
  /**
   * Set the callback after construction
   */
  setCallback(callback: CounterCallback): void;
}

/**
 * Counter object that calls back to JS on each increment
 */
export class Counter extends UniffiAbstractObject implements CounterInterface {
  readonly [uniffiTypeNameSymbol] = 'Counter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ callStatus => {
        return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_constructor_counter_new(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeCounterObjectFactory.bless(pointer);
  }

  public get(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ callStatus => {
          return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_method_counter_get(
            uniffiTypeCounterObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public increment(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ callStatus => {
          return nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_method_counter_increment(
            uniffiTypeCounterObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * Set the callback after construction
   */
  public setCallback(callback: CounterCallback): void {
    uniffiCaller.rustCall(
      /*caller:*/ callStatus => {
        nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_method_counter_set_callback(
          uniffiTypeCounterObjectFactory.clonePointer(this),
          FfiConverterTypeCounterCallback.lower(callback),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeCounterObjectFactory.pointer(this);
      uniffiTypeCounterObjectFactory.freePointer(pointer);
      uniffiTypeCounterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Counter {
    return uniffiTypeCounterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeCounterObjectFactory: UniffiObjectFactory<CounterInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): CounterInterface {
        const instance = Object.create(Counter.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'Counter';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ status =>
            nativeModule().ubrn_uniffi_internal_fn_method_counter_ffi__bless_pointer(
              p,
              status,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: CounterInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: CounterInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ callStatus =>
            nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_clone_counter(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ callStatus =>
            nativeModule().ubrn_uniffi_ankurah_rn_bindings_fn_free_counter(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      isConcreteType(obj: any): obj is CounterInterface {
        return (
          obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Counter'
        );
      },
    };
  })();
// FfiConverter for CounterInterface
const FfiConverterTypeCounter = new FfiConverterObject(
  uniffiTypeCounterObjectFactory,
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_ankurah_rn_bindings_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_get_default_storage_path() !==
    58295
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_get_default_storage_path',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_get_node_id() !==
    54456
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_get_node_id',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_greet() !==
    37002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_greet',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_greet_async() !==
    42141
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_greet_async',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_init_node() !==
    57597
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_init_node',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_is_node_initialized() !==
    63215
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_is_node_initialized',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_func_setup_logging() !==
    62540
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_func_setup_logging',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_method_counter_get() !==
    1235
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_method_counter_get',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_method_counter_increment() !==
    57291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_method_counter_increment',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_method_counter_set_callback() !==
    16147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_method_counter_set_callback',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_constructor_counter_new() !==
    39574
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_constructor_counter_new',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_method_countercallback_on_update() !==
    32332
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_method_countercallback_on_update',
    );
  }
  if (
    nativeModule().ubrn_uniffi_ankurah_rn_bindings_checksum_method_logcallback_on_log() !==
    30753
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ankurah_rn_bindings_checksum_method_logcallback_on_log',
    );
  }

  uniffiCallbackInterfaceCounterCallback.register();
  uniffiCallbackInterfaceLogCallback.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAnkurahError,
    FfiConverterTypeCounter,
  },
});
